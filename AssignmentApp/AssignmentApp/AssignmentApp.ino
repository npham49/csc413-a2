#include <LiquidCrystal_I2C.h>

#include <Wire.h>
#include <MFRC522.h>
#include <SPI.h>

// Define RST and SS pins for each reader
#define RST_PIN 9
#define SS_1_PIN 10
#define SS_2_PIN 8

#define NR_OF_READERS 2
byte ssPins[] = {SS_1_PIN, SS_2_PIN};
MFRC522 mfrc522[NR_OF_READERS];

LiquidCrystal_I2C lcd(0x27,  16, 2);

// State 0 read 11
// State 1 read 12
// State 2 read 21
// State 3 read 22
// State 4 mendel f1 show
// State 5 read 31
// State 6 read 32
// State 7 mendel f2 show
// State 8 error
int state = 0;
bool just_changed = true;
String f1_result;
String f2_result;

String input11;
String input12;
String input1;
String input21;
String input22;
String input2;
String input31;
String input32;
String input3;

// Function to generate Punnett square and return all 16 offspring
// 16 slot matrix is generated by combining the 2 parents gametes
// Each gamete is a 2-character string, each character is an allele
// The gametes are combined in the following way:
// p1_gametes[0][0] + p2_gametes[0][0]
// p1_gametes[0][0] + p2_gametes[0][1]
// p1_gametes[0][1] + p2_gametes[0][0]
// p1_gametes[0][1] + p2_gametes[0][1]
void generatePunnettSquare(String parent1, String parent2, String offspring[16]) {
  // Extract alleles from parents
  char p1_a1 = parent1.charAt(0), p1_a2 = parent1.charAt(1);
  char p1_b1 = parent1.charAt(2), p1_b2 = parent1.charAt(3);
  char p2_a1 = parent2.charAt(0), p2_a2 = parent2.charAt(1);
  char p2_b1 = parent2.charAt(2), p2_b2 = parent2.charAt(3);
  
  // Generate all 16 combinations
  int index = 0;
  
  // Parent1 gametes: a1b1, a1b2, a2b1, a2b2
  // Parent2 gametes: a1b1, a1b2, a2b1, a2b2
  char p1_gametes[4][2] = {{p1_a1,p1_b1}, {p1_a1,p1_b2}, {p1_a2,p1_b1}, {p1_a2,p1_b2}};
  char p2_gametes[4][2] = {{p2_a1,p2_b1}, {p2_a1,p2_b2}, {p2_a2,p2_b1}, {p2_a2,p2_b2}};

  // Matrix calculation for creating the punett square
  // On each row we would add the 2 gametes together and then sort them by dominant first
  // Iterate over the rows
  for (int i = 0; i < 4; i++) {
    // Iterate over the collumns
    for (int j = 0; j < 4; j++) {
      String child = "";
      
      // Combine A alleles and sort (A before a)
      char a_alleles[2] = {p1_gametes[i][0], p2_gametes[j][0]};
      if (a_alleles[0] > a_alleles[1]) {
        char temp = a_alleles[0];
        a_alleles[0] = a_alleles[1];
        a_alleles[1] = temp;
      }
      
      // Combine B alleles and sort (B before b)
      char b_alleles[2] = {p1_gametes[i][1], p2_gametes[j][1]};
      if (b_alleles[0] > b_alleles[1]) {
        char temp = b_alleles[0];
        b_alleles[0] = b_alleles[1];
        b_alleles[1] = temp;
      }
      
      child += a_alleles[0];
      child += a_alleles[1];
      child += b_alleles[0];
      child += b_alleles[1];
      
      offspring[index] = child;
      index++;
    }
  }
}

// Function to calculate F2 phenotype ratios, get the matrix from generatePunnettSquare
// Calculate ratio through the following gene types:
// A_B_
// A_bb
// aaB_
// aabb
String calculateF2Ratio(String parent1, String parent2) {
  String offspring[16];
  generatePunnettSquare(parent1, parent2, offspring);
  
  // The 4 ratios
  int counts[4] = {0, 0, 0, 0}; // A_B_, A_bb, aaB_, aabb
  
  // Count phenotypes
  for (int i = 0; i < 16; i++) {
    String genotype = offspring[i];
    bool hasA = (genotype.charAt(0) == 'A' || genotype.charAt(1) == 'A');
    bool hasB = (genotype.charAt(2) == 'B' || genotype.charAt(3) == 'B');
    
    if (hasA && hasB) counts[0]++;      // A_B_
    else if (hasA && !hasB) counts[1]++; // A_bb
    else if (!hasA && hasB) counts[2]++; // aaB_
    else counts[3]++;                    // aabb
  }
  
  // Simple GCD calculation without recursion
  int gcd = counts[0];
  for (int i = 1; i < 4; i++) {
    if (counts[i] > 0) {
      int a = gcd, b = counts[i];
      while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
      }
      gcd = a;
    }
  }
  
  if (gcd == 0) gcd = 1; // Prevent division by zero
  
  // Create ratio string
  String ratio = "";
  for (int i = 0; i < 4; i++) {
    ratio += String(counts[i] / gcd);
  }
  
  return ratio;
}

// Simple function to print results
void printResults(String parent1, String parent2) {
  Serial.println("Cross: " + parent1 + " Ã— " + parent2);
  String ratio = calculateF2Ratio(parent1, parent2);
  Serial.println("F2 Ratio: " + ratio + " (A_B_:A_bb:aaB_:aabb)");
  Serial.println("------------------------");
}

// Take the first allele from each parent and return it as the first possible combination
String mendelF1Generator(String parent1, String parent2) {
  // Extract alleles from each parent
  // Parent format: AABB -> A,A,B,B or AaBb -> A,a,B,b
  char p1_allele1_A = parent1.charAt(0);  // First A locus allele
  char p1_allele2_A = parent1.charAt(1);  // Second A locus allele
  char p1_allele1_B = parent1.charAt(2);  // First B locus allele
  char p1_allele2_B = parent1.charAt(3);  // Second B locus allele
  
  char p2_allele1_A = parent2.charAt(0);  // First A locus allele
  char p2_allele2_A = parent2.charAt(1);  // Second A locus allele
  char p2_allele1_B = parent2.charAt(2);  // First B locus allele
  char p2_allele2_B = parent2.charAt(3);  // Second B locus allele
  
  // Generate the first possible F1 combination
  // Take first allele from each locus of each parent
  String f1_offspring = "";
  
  // For A locus: take first allele from parent1 and first allele from parent2
  f1_offspring += p1_allele1_A;
  f1_offspring += p2_allele1_A;
  
  // For B locus: take first allele from parent1 and first allele from parent2
  f1_offspring += p1_allele1_B;
  f1_offspring += p2_allele1_B;
  
  // Sort alleles within each locus to maintain standard format (dominant first)
  String result = "";
  
  // Sort A locus alleles (A comes before a)
  if (f1_offspring.charAt(0) <= f1_offspring.charAt(1)) {
    result += f1_offspring.charAt(0);
    result += f1_offspring.charAt(1);
  } else {
    result += f1_offspring.charAt(1);
    result += f1_offspring.charAt(0);
  }
  
  // Sort B locus alleles (B comes before b)
  if (f1_offspring.charAt(2) <= f1_offspring.charAt(3)) {
    result += f1_offspring.charAt(2);
    result += f1_offspring.charAt(3);
  } else {
    result += f1_offspring.charAt(3);
    result += f1_offspring.charAt(2);
  }
  
  return result;
}

void printUID(byte *buffer, byte length) {
  for (byte i = 0; i < length; i++) {
    if (buffer[i] < 0x10)
      Serial.print("0");
    Serial.print(buffer[i], HEX);
    if (i != length - 1)
      Serial.print(":");
  }
}
uint32_t printTagID(byte *buffer, byte length) {
  uint32_t tagID = 0;
  for (byte i = 0; i < length; i++) {
    tagID = (tagID << 8) | buffer[i];
  }
  // Serial.print(tagID);
  return tagID;
}

uint32_t getTagNumber(byte *uid) {
  return ((uint32_t)uid[0] << 24) | ((uint32_t)uid[1] << 16) |
         ((uint32_t)uid[2] << 8) | ((uint32_t)uid[3]);
}

// based on the state, read the input into it appropriate variable
void readInput(String input) {
  if (state == 0) {
    input11 = input;
    checkError(input11, "A", "a");
    if (state != 8) {
      state = 1;
      just_changed = true;
    }
  } else if (state == 1) {
    input12 = input;
    checkError(input12, "B", "b");
    if (state != 8) {
      input1 = input11 + input12;
      state = 2;
      just_changed = true;
    }
  } else if (state == 2) {
    input21 = input;
    checkError(input21, "A", "a");
    if (state != 8) {
      state = 3;
      just_changed = true;
    }
  } else if (state == 3) {
    input22 = input;
    checkError(input22, "B", "b");
    if (state != 8) {
      input2 = input21 + input22;
      state = 4;
      just_changed = true;
    }
  } else if (state == 5) {
    input31 = input;
    checkError(input31, "A", "a");
    if (state != 8) {
      state = 6;
      just_changed = true;
    }
  } else if (state == 6) {
    input32 = input;
    checkError(input32, "B", "b");
    if (state != 8) {
      input3 = input31 + input32;
      state = 7;
      just_changed = true;
    }
  }
}

void checkError(String input, String expected1, String expected2) {
  if (input.charAt(0) != expected1.charAt(0) && input.charAt(0) != expected2.charAt(0)) {
    state = 8; // Move to error state
    just_changed = true;
    return;
  }
}

// Example usage function
void setup() {
  Serial.begin(9600);
  while (!Serial)
    ; // Wait for serial connection (for Leonardo/Micro)

  SPI.begin(); // Initialize SPI bus

  // Initialize each reader
  for (uint8_t reader = 0; reader < NR_OF_READERS; reader++) {
    mfrc522[reader].PCD_Init(ssPins[reader], RST_PIN);
    Serial.print(F("Reader "));
    Serial.print(reader);
    Serial.print(F(" initialized on SS pin "));
    Serial.println(ssPins[reader]);
  }

  lcd.init();
  // turn on the backlight
  lcd.backlight();
  
  // Test examples
  Serial.println("Mendel F1 Generator Examples:");
  Serial.println("Parent1: AABB, Parent2: aabb -> " + mendelF1Generator("AABB", "aabb"));
  Serial.println("Parent1: AaBb, Parent2: AaBb -> " + mendelF1Generator("AaBb", "AaBb"));
  Serial.println("Parent1: AAbb, Parent2: aaBB -> " + mendelF1Generator("AAbb", "aaBB"));
  Serial.println("Parent1: Aabb, Parent2: AaBb -> " + mendelF1Generator("Aabb", "AaBb"));

  Serial.println("Punnett Square and F2 Ratio Calculator\n");
  
  // Test examples
  printResults("AaBb", "AaBb");  // Should be 9331
  printResults("AABB", "aabb");  // Should be 1000
  printResults("AABb", "AaBb");  // Should be 3100
  printResults("Aabb", "aaBb");  // Should be 1111
  printResults("AABB", "AABB");  // Should be 1000
}




void setupReaders() {
  for (uint8_t reader = 0; reader < NR_OF_READERS; reader++) {
    if (mfrc522[reader].PICC_IsNewCardPresent() &&
        mfrc522[reader].PICC_ReadCardSerial()) {
      Serial.print(F("Reader "));
      Serial.print(reader);
      Serial.print(F(" UID: "));
      printUID(mfrc522[reader].uid.uidByte, mfrc522[reader].uid.size);
      // uint32_t tagID = printTagID(mfrc522[reader].uid.uidByte,
      // mfrc522[reader].uid.size);
      uint32_t tagID = getTagNumber(mfrc522[reader].uid.uidByte);

      Serial.print("\nTag Number: ");
      Serial.print(tagID);
      Serial.println();
      if (tagID == 2713759238 || tagID == 2976165638) {
        Serial.println("Color: Yellow");
      } else if (tagID == 4056264198 || tagID == 1902292742) {
        Serial.println("Color: Green");
      } else if (tagID == 2439032582 || tagID == 3776032262) {
        Serial.println("Color: Red");
      } else if (tagID == 22916870 || tagID == 566537734) {
        Serial.println("Shape: Constricted");
      } else if (tagID == 3244207878 || tagID == 1371713030) {
        Serial.println("Shape: Inflated");
      } else if (tagID == 566799878 || tagID == 2983046662) {
        Serial.println("Shape: Round");
      } else if (tagID == 3519786502 || tagID == 4056526342) {
        Serial.println("Shape: Long");
      } else if (tagID == 2166009862 || tagID == 1) {
        Serial.println("Gene: AA");
        readInput("AA");
      } else if (tagID == 2971185158 || tagID == 2) {
        Serial.println("Gene: Aa");
        readInput("Aa");
      } else if (tagID == 560639750 || tagID == 3) {
        Serial.println("Gene: aa");
        readInput("aa");
      } else if (tagID == 1365815046 || tagID == 4) {
        Serial.println("Gene: BB");
        readInput("BB");
      } else if (tagID == 2170990342 || tagID == 5) {
        Serial.println("Gene: Bb");
        readInput("Bb");
      } else if (tagID == 1373211835 || tagID == 6) {
        Serial.println("Gene: bb");
        readInput("bb");
      }

      mfrc522[reader].PICC_HaltA();      // Halt the card
      mfrc522[reader].PCD_StopCrypto1(); // Stop encryption
    }
  }
}

void askForInput(String message) {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print(message);
}

void askUserForInputAtState(int state) {
  if (state == 0) {
    askForInput("Please scan");
  } else if (state == 1) {
    askForInput("Please scan");
  } else if (state == 2) {
    askForInput("Please scan");
  } else if (state == 3) {
    askForInput("Please scan");
  } else if (state == 6) {
    askForInput("Please scan");
  }
}

void loop() {
  setupReaders();
  askUserForInputAtState(state);

  if (just_changed) {
    lcd.clear();

    if (state==4) { 

      f1_result = mendelF1Generator(input1,input2);
      //wait  for a second
      delay(1000);
      // tell the screen to write on the top row
      lcd.setCursor(0,0);
      // tell the screen to write "hello, from" on the top  row
      lcd.print("I1:" + input1 + "*" + "I2:" + input2);
      // tell the screen to write on the bottom  row
      lcd.setCursor(0,1);
      // tell the screen to write "Arduino_uno_guy"  on the bottom row
      // you can change whats in the quotes to be what you want  it to be!
      lcd.print("F1= " + f1_result);

      just_changed = false;
      state = 5;
    } else if (state==7) {

      f2_result = calculateF2Ratio(f1_result, input3);
      printResults(f1_result, input3);  // Should be 9331
      //wait  for a second
      delay(1000);
      // tell the screen to write on the top row
      lcd.setCursor(0,0);
      // tell the screen to write "hello, from" on the top  row
      lcd.print("F1:" + f1_result + "*" + "I3:" +  input3);
      // tell the screen to write on the bottom  row
      lcd.setCursor(0,1);
      // tell the screen to write "Arduino_uno_guy"  on the bottom row
      // you can change whats in the quotes to be what you want  it to be!
      lcd.print("F2 ratio=" + f2_result);
    } else if (state == 8) {
      lcd.clear();
      lcd.setCursor(0,0);
      lcd.print("Error");
      lcd.setCursor(0,1);
      lcd.print("Please try again");

      // wait for 1 second
      delay(1000);
      // go back to state 0
      state = 0;
      just_changed = true;
    }
    just_changed = false;
    Serial.println(state);
  }
}